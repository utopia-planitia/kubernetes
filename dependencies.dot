digraph {

subgraph cluster_master {
    label="Kubernetes";
    color=grey;
    
    kubelet     [label="Kubelet"]
    kubeproxy   [label="Kube Proxy"]
    masterproxy [label="Master proxy"]
    dnscache    [label="Node Local DNS Cache"]
    internaldns [label="Core DNS"]
    etcd        [label="Etcd"]
    weave       [label="Weave"]
    cni         [label="Container Network Interface"]

    subgraph cluster_master {
        label="Master";
        color=grey;

        apiserver   [label="Apiserver"]
        controller  [label="Controller Manager"]
        scheduler   [label="Scheduler"]
    }

}

upstream_dns [label="public DNS server",color="red"]

etcd -> etcd                [label="forms a paxos cluster"]
apiserver -> etcd           [label="stores state in"]
apiserver -> nodeports      [label="listens on Nodeport 6443"]
controller -> apiserver     [label="consolidates\ndesired state\nvs\nactual state "]
scheduler -> apiserver      [label="caculates node\nwith matching\nresource request"]
kubelet -> apiserver        [label="requests desired state"]
kubelet -> masterproxy      [label="requests desired state"]
masterproxy -> apiserver    [label="loadbalances\nTCP traffic"]
systemd -> kubelet          [label="starts"]
container -> dnscache       [label="resolves domain names via"]
kubelet -> docker           [label="starts and stops\ncontainers via"]
kubelet -> cni              [label="requests networking\nfor pod"]
cni -> weave                [label="setups up networking\nfor pods"]
kubeproxy -> apiserver      [label="requests service\nIPs and its pod\nendpoints"]
kubeproxy -> iptables       [label="configures to\nredirect service\ntraffic to pods"]
weave -> apiserver          [label="discovers peers via"]
weave -> weave              [label="creates overlay\nnetwork between nodes"]
internaldns -> apiserver    [label="reads service IPs\nand endpoints"]
internaldns -> upstream_dns [label="resolves external hostnames"]
dnscache -> internaldns     [label="uses TCP for DNS"]

}